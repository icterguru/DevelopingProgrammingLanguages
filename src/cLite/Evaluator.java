package cLite;


/**

 * An Evaluator evaluates parse trees generated by the Parser.
 * 
 * Written by Tarif Haque
 */

import java.util.ArrayList;

public class Evaluator {
	
	/**
	 * The main evaluating function.
	 */
	private Lexeme eval(Lexeme tree, Environment env) {
		
		String type = tree.getType();
		
		switch(type) {
			case "NUMBER": 
				return tree;
			case "STRING":
				return tree;
			case "VARIABLE":
				return env.lookup(tree);
			
			// parenthesized expression
			case "OPAREN": 
				return eval(tree.right(), env);
			
			// operators (both sides evaluated)
			case "PLUS":
			case "MINUS":
			case "TIMES":
			case "DIVIDES":
			case "MODULO":
			case "EQ":
			case "GREATERTHAN":
			case "LESSTHAN":
			case "GREATEREQUAL":
			case "LESSEQUAL":
				return evalSimpleOp(tree, env);
			
			// AND and OR short-circuit
			case "AND":
			case "OR": 
				return evalShortCircuitOp(tree, env);
			case "ASSIGN": 
				return evalAssign(tree, env);
			case "FUNCTION": return evalFuncDef(tree,env);
			case "ARG-LIST": return evalArgs(tree,env);
            
			// imperative constructs
            case "IF": return evalIf(tree, env);
            case "ELSE": return evalElse(tree, env);
            case "WHILE": return evalWhile(tree,env);
            
            // function calls
            case "FUNC-CALL": return evalFuncCall(tree,env);
            
            // program and function body are parsed as blocks
            case "BLOCK": return evalBlock(tree,env);
            case "STATEMENT-LIST": return evalStatementList(tree, env);
            case "PROGRAM": return evalProgram(tree, env);
            case "PRINT": return evalPrint(tree, env);
            case "PRINTLN": return evalPrintln(tree, env);
            case "ARRAY": return evalArray(tree, env);
            
            default: {
            	System.err.println("Evaluator Bad Expression: " + type);
            }
		}
			
		return null;
	}

	private Lexeme evalArray(Lexeme tree, Environment env) {
		ArrayList<Lexeme> list = new ArrayList<Lexeme>();
		Lexeme temp = tree;
		tree = tree.right();
		Lexeme result = null;
		
		while (tree.left() != null) { 
			result = eval(tree.left(), env);
			tree.setLeft(result);
			list.add(result);
			tree = tree.right();
		}
		
		temp.setArrayList(list);
		return temp;
	}

	private Lexeme evalPrintln(Lexeme tree, Environment env) {
		Lexeme result = eval(tree.right(), env);
		System.out.println(result.toString());
		return result;
	}

	private Lexeme evalPrint(Lexeme tree, Environment env) {
		Lexeme result = eval(tree.right(), env);
		System.out.print(result.toString());
		return result;
	}

	private Lexeme evalElse(Lexeme tree, Environment env) {
		return eval(tree.right(), env);
	}

	private Lexeme evalStatementList(Lexeme tree, Environment env) {
		Lexeme result = null;
		while (tree.left() != null) { 
			result = eval(tree.left(), env);
			tree = tree.right();
		}
		return result;
	}

	private Lexeme evalProgram(Lexeme tree, Environment env) {
		Lexeme result = null;
		while (tree.left() != null) { 
			result = eval(tree.left(), env);
			tree = tree.right();
		}
		return result;
	}

	private Lexeme evalWhile(Lexeme tree, Environment env) {
		Lexeme result = null;
		while (eval(tree.left(), env).getStrValue().equals("true")) {
			result = eval(tree.right(), env);
		}
		return result;
	}

	private Lexeme evalIf(Lexeme tree, Environment env) {
		Lexeme result;
		String bool = eval(tree.left().left(), env).getStrValue();
		if (bool.equals("true")) {
			result = eval(tree.right(), env);
		} else {
			result = eval(tree.left().right(), env);
		}
		return result;
	}

	private Lexeme evalFuncDef(Lexeme tree, Environment env) {
		tree.setDefiningEnv(env);
		env.insert(tree.left(), tree);
		return tree;
	}

	private Lexeme evalFuncCall(Lexeme tree, Environment env) {
		Lexeme closure = env.lookup(tree.left());
		Environment defEnv = closure.getDefiningEnv();
		Lexeme args = tree.right();
		Lexeme params = closure.right().left();
		Lexeme body = closure.right().right();
		Lexeme eargs = evalArgs(args, env);
		Environment xenv = defEnv.extend(params, eargs);
		return eval(body, xenv);
	}

	private Lexeme evalArgs(Lexeme tree, Environment env) {
		Lexeme temp = tree; 
		Lexeme result = null;
		while (tree.left() != null) { 
			result = eval(tree.left(), env);
			tree.setLeft(result);
			tree = tree.right();
		}
		return temp;
	}

	/**
	 * The value of a block is the value of the last statement
	 * executed in the block. 
	 */
	private Lexeme evalBlock(Lexeme tree, Environment env) {
		Lexeme result = eval(tree.right(), env);
		return result;
	}

	private Lexeme evalAssign(Lexeme tree, Environment env) {
		Lexeme value = eval(tree.right(), env);
		env.update(tree.left(), value);
		return value;
	}

	private Lexeme evalShortCircuitOp(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		if (tree.getType() == "OR") {
			if (left.getStrValue().equals("true")) return new Lexeme("BOOLEAN", "true");
			else if (right.getStrValue().equals("true")) return new Lexeme("BOOLEAN", "true"); 
		}
		
		if (tree.getType() == "AND") {
			if (left.getStrValue().equals("false")) return new Lexeme("BOOLEAN", "false");
			else if (right.getStrValue().equals("true")) return new Lexeme("BOOLEAN", "true"); 
		}
		
		return new Lexeme("BOOLEAN", "false");
	}

	private Lexeme evalSimpleOp(Lexeme tree, Environment env) {
		if (tree.getType().equals("PLUS")) return evalPlus(tree,env);
        if (tree.getType().equals("MINUS")) return evalMinus(tree,env);
        if (tree.getType().equals("TIMES")) return evalTimes(tree,env);
        if (tree.getType().equals("DIVIDES")) return evalDivides(tree,env);
        if (tree.getType().equals("MODULO")) return evalModulo(tree,env);
        if (tree.getType().equals("EQ")) return evalEquals(tree,env);
        if (tree.getType().equals("GREATERTHAN")) return evalGreaterThan(tree,env);
        if (tree.getType().equals("LESSTHAN")) return evalLessThan(tree,env);
        if (tree.getType().equals("GREATEREQUAL")) return evalGreaterEqual(tree,env);
        if (tree.getType().equals("LESSEQUAL")) return evalLessEqual(tree,env);
		return null;
	}

	private Lexeme evalLessEqual(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
	
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER")) {
			if (left.getIntValue() <= right.getIntValue())
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		return null;
	}

	private Lexeme evalGreaterEqual(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
	
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER")) {
			if (left.getIntValue() >= right.getIntValue())
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		return null;
	}

	private Lexeme evalLessThan(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER")) {
			if (left.getIntValue() < right.getIntValue())
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		return null;
	}

	private Lexeme evalGreaterThan(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
	
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER")) {
			if (left.getIntValue() > right.getIntValue())
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		return null;
	}

	private Lexeme evalEquals(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
	
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER")) {
			if (left.getIntValue() == right.getIntValue())
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		
		if (left.getType().equals("STRING") && right.getType().equals("STRING")) {
			if (left.getStrValue().equals(right.getStrValue()))
				return new Lexeme("BOOLEAN", "true");
			else return new Lexeme("BOOLEAN", "false");
		}
		
		return null;
	}

	private Lexeme evalTimes(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
	
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER"))
			return new Lexeme("NUMBER", left.getIntValue() * right.getIntValue());
		
		return null;
	}

	private Lexeme evalDivides(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER"))
			return new Lexeme("NUMBER", left.getIntValue() / right.getIntValue());
		
		return null;
	}

	private Lexeme evalModulo(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER"))
			return new Lexeme("NUMBER", left.getIntValue() % right.getIntValue());
		
		return null;
	}

	private Lexeme evalMinus(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		if (left.getType().equals("NUMBER") && right.getType().equals("NUMBER"))
			return new Lexeme("NUMBER", left.getIntValue() - right.getIntValue());
		
		return null;
	}

	private Lexeme evalPlus(Lexeme tree, Environment env) {
		Lexeme left = eval(tree.left(), env);
		Lexeme right = eval(tree.right(), env);
		
		String leftType = left.getType();
		String rightType = right.getType();
		
		if (leftType.equals("NUMBER")) {
			if (rightType.equals("NUMBER"))
				return new Lexeme("NUMBER", left.getIntValue() + right.getIntValue());
			else if (rightType.equals("STRING"))
				return new Lexeme("STRING", left.getStrValue() + right.getStrValue());
		}
		
		if (left.getType().equals("STRING") && right.getType().equals("STRING"))
			return new Lexeme("STRING", left.getStrValue() + right.getStrValue());
		
		
		return null;
	}
	
	public Lexeme launchEval(Lexeme root, Environment env) {
		System.out.println("-- PROGRAM EVALUATION OUTPUT --");
		return eval(root, env);
	}

}